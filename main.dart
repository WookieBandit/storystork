import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'package:flutter/foundation.dart'; // Required for compute
import 'package:package_info_plus/package_info_plus.dart';
import 'package:flutter/services.dart';
import 'lesson_examples.dart';

// Firebase and App-specific Imports
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'firebase_options.dart'; // Generated by FlutterFire

// Screen Imports
import 'login_screen.dart';
import 'library_screen.dart';
import 'public_browse_screen.dart';
import 'persona_list_screen.dart';

// Widget/Component Imports
// CharacterDropdown is no longer directly used in HomePage UI
import 'api_config.dart'; // For API Key and Endpoint

// Model Imports
import 'models/persona_model.dart';

// Main function
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
  runApp(const MyApp());
}

// Root Application Widget
class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'storystork',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      debugShowCheckedModeBanner: false,
      home: StreamBuilder<User?>(
        stream: FirebaseAuth.instance.userChanges(),
        builder: (context, snapshot) {
          print('--- StreamBuilder building (using userChanges) ---');
          print('Connection state: ${snapshot.connectionState}');

          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Scaffold(key: ValueKey('loading_screen'), body: Center(child: CircularProgressIndicator()));
          }

          if (snapshot.hasData && snapshot.data != null) {
            print('StreamBuilder: User is logged in (${snapshot.data!.uid}). Returning HomePage.');
            return HomePage(key: ValueKey(snapshot.data!.uid));
          } else {
            print('StreamBuilder: No user is logged in. Returning LoginScreen.');
            return const LoginScreen(key: ValueKey('loginScreen'));
          }
        },
      ),
    );
  }
}

// AI Response Processing Function
Map<String, String> _processAiResponse(String responseBody) {
  String rawGeneratedText = 'Could not parse AI response.';
  String extractedSynopsis = 'Synopsis could not be generated by AI.';
  String mainContent = rawGeneratedText; // Default mainContent to the full raw text

  final String synopsisMarker = 'SYNOPSIS_TEXT:';

  try {
    Map<String, dynamic> responseData = jsonDecode(responseBody);
    if (responseData['candidates'] != null && responseData['candidates'].isNotEmpty) {
      var firstCandidate = responseData['candidates'][0];
      if (firstCandidate['content'] != null && 
          firstCandidate['content']['parts'] != null && 
          firstCandidate['content']['parts'].isNotEmpty) {
        rawGeneratedText = firstCandidate['content']['parts'][0]['text'] ?? 'No text found in AI response part.';

        // Try to find and extract the AI-generated synopsis
        int synopsisStartIndex = rawGeneratedText.indexOf(synopsisMarker);
        if (synopsisStartIndex != -1) {
          // Synopsis marker found
          String potentialSynopsis = rawGeneratedText.substring(synopsisStartIndex + synopsisMarker.length).trim();
          mainContent = rawGeneratedText.substring(0, synopsisStartIndex).trim(); // Text before marker is main content

          // Simple way to get 2-3 sentences for synopsis if AI gives more, or just take what it gives.
          // For now, let's assume the AI follows the "2-3 sentence" instruction.
          extractedSynopsis = potentialSynopsis; 
          print('AI-Generated Synopsis extracted: $extractedSynopsis');
        } else {
          // Synopsis marker NOT found, fall back to old method (first few sentences of main content)
          print('SYNOPSIS_TEXT: marker not found. Falling back to extracting first ~2 sentences from main content for synopsis.');
          mainContent = rawGeneratedText; // Ensure mainContent is the full text if no marker
          List<String> sentences = mainContent.split(RegExp(r'(?<=[.!?])\s+'));
          if (sentences.isNotEmpty) {
            extractedSynopsis = sentences.take(2).join(' ').trim();
            if (!RegExp(r'[.!?]$').hasMatch(extractedSynopsis) && extractedSynopsis.isNotEmpty) {
              extractedSynopsis += '.';
            }
          } else if (mainContent.isNotEmpty) {
             extractedSynopsis = mainContent.substring(0, (mainContent.length > 150 ? 150 : mainContent.length)) + (mainContent.length > 150 ? "..." : "");
          }
          print('Fallback Synopsis generated: $extractedSynopsis');
        }
      }
    }
  } catch (e) {
    print('Error processing AI response in _processAiResponse: $e');
    mainContent = 'Error processing AI response: $e';
    extractedSynopsis = 'Error processing synopsis.';
  }
  return {'synopsis': extractedSynopsis, 'fullText': mainContent};
}

// HomePage Widget
class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  // Section: State Variables
  final TextEditingController _promptController = TextEditingController();
  List<String> _selectedThemes = [];
  final int _maxThemes = 2;
  final List<String> _availableThemes = const ['Fantasy', 'Science Fiction', 'Mystery', 'Historical', 'Adventure', 'Humor', 'Slice of Life'];
  
  List<String> _selectedCharacters = [];
  final int _maxCharacters = 2;
  final List<String> _availableCharacters = const ['Dragon', 'Wizard', 'Alien', 'Robot', 'Detective', 'Knight', 'Goblin', 'Orc', 'Space Pirate', 'Robot Companion', 'Fairy', 'Unicorn'];

  Persona? _selectedPersonaObject;
  final String _noPersonaOptionText = 'No Persona';
  
  String _selectedLength = 'Quick Read (<5 min)'; 
  final List<String> _availableLengths = const ['Quick Read (<5 min)', 'Standard Read (5+ min)'];

  String _contentType = 'Story';
  
  String? _selectedAgeRange;
  final List<String> _availableAgeRanges = const ['Not Specified', '1-3 years', '3-5 years', '5-7 years', '7-10 years'];
  
  List<String> _selectedLessons = [];
  final List<String> _availableLessons = const ['Friendship & Loyalty', 'Kindness & Empathy', 'Honesty & Integrity', 'Resilience & Perseverance', 'Social Behavior & Respect'];
  final int _maxLessons = 1;

  String _synopsis = 'Synopsis will appear here...';
  String _fullText = 'Full content will appear here...';
  String _appVersion = 'Loading version...';

  List<Persona> _userPersonas = [];
  bool _isLoadingPersonas = true;
  bool _isGenerating = false;

    // --- NEW: State variables to store last used inputs for regeneration ---
  String? _lastUsedPrompt;
  List<String> _lastUsedThemes = [];
  List<String> _lastUsedCharacters = [];
  Persona? _lastUsedPersonaObject;
  String? _lastUsedLength;
  String? _lastUsedContentType;
  String? _lastUsedAgeRange;
  List<String> _lastUsedLessons = [];
  bool _contentHasBeenGenerated = false; // To control visibility of Regenerate button
  // --- END OF NEW STATE VARIABLES ---

  @override
  void initState() {
    super.initState();
    _loadAppVersion();
    _fetchUserPersonas();
    if (_availableAgeRanges.isNotEmpty) {
        _selectedAgeRange = _availableAgeRanges[0]; 
    }
  }

  @override
  void dispose() {
    _promptController.dispose();
    super.dispose();
  }

  // Helper to ensure setState is only called if widget is still mounted
  void setStateIfMounted(void Function() fn) {
    if (mounted) {
      setState(fn);
    }
  }

  Future<void> _loadAppVersion() async {
    final PackageInfo packageInfo = await PackageInfo.fromPlatform();
    if (mounted) setStateIfMounted(() => _appVersion = packageInfo.version);
    print('App Version Loaded: $_appVersion');
  }

  Future<void> _fetchUserPersonas() async {
    if (mounted) setStateIfMounted(() => _isLoadingPersonas = true);
    User? currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      if (mounted) setStateIfMounted(() { _isLoadingPersonas = false; _userPersonas = []; _selectedPersonaObject = null; });
      return;
    }
    try {
      QuerySnapshot personaSnapshot = await FirebaseFirestore.instance
          .collection('personas')
          .where('userId', isEqualTo: currentUser.uid)
          .orderBy('personaName', descending: false)
          .get();
      List<Persona> fetchedPersonas = personaSnapshot.docs.map((doc) => Persona.fromFirestore(doc)).toList();
      if (mounted) {
        setStateIfMounted(() {
          _userPersonas = fetchedPersonas;
          _isLoadingPersonas = false;
          if (_selectedPersonaObject != null && !_userPersonas.any((p) => p.id == _selectedPersonaObject!.id)) {
            _selectedPersonaObject = null;
          }
        });
      }
    } catch (e) {
      print('Error fetching personas: $e');
      if (mounted) {
        setStateIfMounted(() => _isLoadingPersonas = false);
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error fetching personas: ${e.toString()}')));
      }
    }
  }
  void _showSnackBar(String message, {bool isError = false}) {
  if (!mounted) return; // Check if the widget is still in the tree
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      backgroundColor: isError ? Colors.redAccent : Theme.of(context).snackBarTheme.backgroundColor, // Use theme color or red for error
      duration: const Duration(seconds: 3),
    ),
  );
}

  Future<void> _showThemeSelectionDialog() async {
    List<String> tempSelectedThemes = List<String>.from(_selectedThemes);
    await showDialog<List<String>>(
      context: context,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: Text('Select Themes (Up to $_maxThemes)'),
              content: SingleChildScrollView(child: ListBody(children: _availableThemes.map((theme) {
                final bool isSelected = tempSelectedThemes.contains(theme);
                return CheckboxListTile(
                  title: Text(theme), value: isSelected,
                  onChanged: (bool? newValue) {
                    setDialogState(() {
                      if (newValue == true) {
                        if (tempSelectedThemes.length < _maxThemes) tempSelectedThemes.add(theme);
                        else if (mounted) {
                          ScaffoldMessenger.of(context).removeCurrentSnackBar();
                          ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('You can select up to $_maxThemes themes only.')));
                        }
                      } else tempSelectedThemes.remove(theme);
                    });
                  },
                );
              }).toList())),
              actions: <Widget>[
                TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(context).pop()),
                TextButton(child: const Text('Done'), onPressed: () => Navigator.of(context).pop(tempSelectedThemes)),
              ],
            );
          },
        );
      },
    ).then((returnedSelectedThemes) {
      if (returnedSelectedThemes != null) {
        if (mounted) setStateIfMounted(() => _selectedThemes = returnedSelectedThemes);
        print('Selected Themes: $_selectedThemes');
      }
    });
  }

  Future<void> _showCharacterSelectionDialog() async {
    List<String> tempSelectedCharacters = List<String>.from(_selectedCharacters);
    await showDialog<List<String>>(
      context: context,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: Text('Select Characters (Up to $_maxCharacters)'),
              content: SingleChildScrollView(child: ListBody(children: _availableCharacters.map((character) {
                final bool isSelected = tempSelectedCharacters.contains(character);
                return CheckboxListTile(
                  title: Text(character), value: isSelected,
                  onChanged: (bool? newValue) {
                    setDialogState(() {
                      if (newValue == true) {
                        if (tempSelectedCharacters.length < _maxCharacters) tempSelectedCharacters.add(character);
                        else if (mounted) {
                          ScaffoldMessenger.of(context).removeCurrentSnackBar();
                          ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('You can select up to $_maxCharacters characters only.')));
                        }
                      } else tempSelectedCharacters.remove(character);
                    });
                  },
                );
              }).toList())),
              actions: <Widget>[
                TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(context).pop()),
                TextButton(child: const Text('Done'), onPressed: () => Navigator.of(context).pop(tempSelectedCharacters)),
              ],
            );
          },
        );
      },
    ).then((returnedSelectedCharacters) {
      if (returnedSelectedCharacters != null) {
        if (mounted) setStateIfMounted(() => _selectedCharacters = returnedSelectedCharacters);
        print('Selected Characters: $_selectedCharacters');
      }
    });
  }

 Future<Map<String, String>> _generateContent({
  required String userPrompt,
  required String contentType,
  required List<String> selectedThemes,
  required List<String> selectedCharacters,
  required Persona? selectedPersonaObject,
  required String? selectedAgeRange,
  required List<String> selectedLessons,
  required String selectedLength,
}) async {
  if(mounted) setStateIfMounted(() => _isGenerating = true);

  String storyTypeInstruction = contentType == 'Story' 
      ? "Craft a creative and engaging children's story. " 
      : "Compose a creative and imaginative children's poem. ";
  
  String lengthInstruction = "";
  int currentMaxTokens;
  if (selectedLength == 'Quick Read (<5 min)') {
    lengthInstruction = "The ${contentType.toLowerCase()} should be concise yet feel complete, suitable for a quick read of less than about 5 minutes, with a clear narrative progression. ";
    currentMaxTokens = 500; 
  } else if (selectedLength == 'Standard Read (5+ min)') {
    lengthInstruction = "The ${contentType.toLowerCase()} should be well-developed and feel complete, suitable for a read of about 5 minutes or more, with a clear narrative arc (beginning, middle, and end). ";
    currentMaxTokens = 800; 
  } else { 
    lengthInstruction = "The ${contentType.toLowerCase()} should be of medium length and feel complete. ";
    currentMaxTokens = 500; 
  }
  
  String basePrompt = storyTypeInstruction + lengthInstruction;

  if (userPrompt.isNotEmpty) {
    basePrompt += "The main idea or prompt is: \"$userPrompt\". ";
  } else {
    basePrompt += "Please come up with an original and imaginative idea. ";
  }

  if (selectedThemes.isNotEmpty) basePrompt += "The ${contentType.toLowerCase()} should subtly weave in the theme(s) of: ${selectedThemes.join(' and ')}. ";
  if (selectedCharacters.isNotEmpty) basePrompt += "The ${contentType.toLowerCase()} should feature: ${selectedCharacters.join(', ')}. ";
  
  if (selectedPersonaObject != null) {
    String personaDetails = " This ${contentType.toLowerCase()} is specifically for ${selectedPersonaObject.personaName}.";
    if (selectedPersonaObject.personaRelationship != null && selectedPersonaObject.personaRelationship!.isNotEmpty) personaDetails += " They are their ${selectedPersonaObject.personaRelationship!.toLowerCase()}.";
    if (selectedPersonaObject.personaAge != null && selectedPersonaObject.personaAge!.isNotEmpty) personaDetails += " This individual is ${selectedPersonaObject.personaAge} old.";
    if (selectedPersonaObject.personaInterests.isNotEmpty) personaDetails += " Their interests include ${selectedPersonaObject.personaInterests.join(', ')}.";
    if (selectedPersonaObject.notes != null && selectedPersonaObject.notes!.isNotEmpty) personaDetails += " Please also keep this in mind: ${selectedPersonaObject.notes}.";
    basePrompt += personaDetails;
  }
  
  if (selectedAgeRange != null && selectedAgeRange != 'Not Specified') {
    basePrompt += " The ${contentType.toLowerCase()}'s complexity, vocabulary, and themes should be suitable for children aged $selectedAgeRange. ";
  }
  
  String fewShotPreamble = "";
  String lessonTopicInstruction = "";
  if (selectedLessons.isNotEmpty) {
    String selectedLesson = selectedLessons.first; 
    if (lessonExamples.containsKey(selectedLesson)) {
      var example = lessonExamples[selectedLesson]!;
      fewShotPreamble = """

To guide the style and impart a meaningful lesson, consider this example related to '$selectedLesson':
Example Title: ${example['title']}
Example Summary: ${example['summary']}
Example Moral/Lesson: ${example['moral']}
This example effectively conveys the lesson of '$selectedLesson' through its narrative and conclusion.
---
Now, keeping such an example in mind for incorporating the lesson and achieving a complete story structure:
""";
      basePrompt = fewShotPreamble + basePrompt;
      lessonTopicInstruction = " The ${contentType.toLowerCase()} should subtly and creatively incorporate a lesson about $selectedLesson.";
    } else {
      lessonTopicInstruction = " The ${contentType.toLowerCase()} should subtly and creatively incorporate a lesson about $selectedLesson.";
    }
  }
  
  String structureInstruction = 
      "Please craft a complete and well-rounded narrative. Ensure the ${contentType.toLowerCase()} flows naturally from an engaging introduction of characters and setting, through a developing plot with clear events or challenges, to a satisfying and conclusive resolution. The story should feel finished. Do not use explicit labels like 'Beginning:', 'Middle:', 'End:', or 'Moral/Lesson:' in your response.";

  String synopsisRequestInstruction = "\n\nFinally, after the main content, please provide a distinct 2-3 sentence synopsis (summary) of the ${contentType.toLowerCase()} you just wrote. Start this synopsis with the exact label 'SYNOPSIS_TEXT:' and nothing else before it on that line.";
  
  String combinedPrompt = basePrompt + lessonTopicInstruction + structureInstruction + synopsisRequestInstruction;
  
  print('--- Sending Combined Prompt to AI (v2.9 - regenerate enabled) ---');
  print(combinedPrompt);
  print('--- End of Prompt ---');
  print('Selected Length: $selectedLength, mapped to maxTokens: $currentMaxTokens');

  Uri uri = Uri.parse('$googleAiApiEndpoint?key=$googleAiApiKey');
  Map<String, dynamic> requestBody = {
    "contents": [{"parts": [{"text": combinedPrompt}]}],
    "generationConfig": { "maxOutputTokens": currentMaxTokens },
  };

  Map<String, String> result = {'synopsis': 'Error generating synopsis.', 'fullText': 'An unexpected error occurred.'};
  try {
    http.Response response = await http.post(uri, headers: {'Content-Type': 'application/json'}, body: jsonEncode(requestBody));
    if (response.statusCode == 200) {
      result = await compute(_processAiResponse, response.body);
    } else {
      print('API request failed: ${response.statusCode} ${response.body}');
      result = {'synopsis': 'Error: API Request Failed', 'fullText': 'Error generating content: ${response.statusCode}\n${response.body}'};
    }
  } catch (e) {
    print('Error making API request: $e');
    result = {'synopsis': 'Error: Network or Processing', 'fullText': 'Network error or exception: Could not connect to AI service or process response.\n$e'};
  } finally {
    if(mounted) setStateIfMounted(() => _isGenerating = false);
  }
  return result;
}

  @override
  Widget build(BuildContext context) {
    List<DropdownMenuItem<Persona?>> personaDropdownItems = [
      DropdownMenuItem<Persona?>(value: null, child: Text(_noPersonaOptionText)),
      ..._userPersonas.map((Persona persona) => DropdownMenuItem<Persona?>(value: persona, child: Text(persona.personaName))).toList(),
    ];
    String characterButtonLabelText = _selectedCharacters.isEmpty ? 'Choose Characters (Up to $_maxCharacters)' : 'Characters (${_selectedCharacters.length}/$_maxCharacters)';
    String themeButtonLabelText = _selectedThemes.isEmpty ? 'Choose Themes (Up to $_maxThemes)' : 'Themes (${_selectedThemes.length}/$_maxThemes)';

    return Scaffold(
      appBar: AppBar(
        title: const Text('storystork'), centerTitle: true,
        actions: <Widget>[ 
          IconButton(icon: const Icon(Icons.logout), tooltip: 'Logout', onPressed: _isGenerating ? null : () async { await FirebaseAuth.instance.signOut(); if (mounted) Navigator.of(context).pushAndRemoveUntil(MaterialPageRoute(builder: (context) => const LoginScreen()), (Route<dynamic> route) => false); }),
          IconButton(icon: const Icon(Icons.library_books), tooltip: 'My Library', onPressed: _isGenerating ? null : () => Navigator.push(context, MaterialPageRoute(builder: (context) => const LibraryScreen()))),
          IconButton(icon: const Icon(Icons.explore), tooltip: 'Browse Public Stories', onPressed: _isGenerating ? null : () => Navigator.push(context, MaterialPageRoute(builder: (context) => const PublicBrowseScreen()))),
          IconButton(icon: const Icon(Icons.face_retouching_natural), tooltip: 'My Personas', onPressed: _isGenerating ? null : () { Navigator.push(context, MaterialPageRoute(builder: (context) => const PersonaListScreen())).then((_) => _fetchUserPersonas()); }),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: ListView(
          children: <Widget>[
            // Section: Content Type (Moved to top)
            const Text('I want a:', style: TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)),
            Row(mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[
              Row(children: [Radio<String>(value: 'Story', groupValue: _contentType, onChanged: (val) => setStateIfMounted(() => _contentType = val!)), const Text('Story')]),
              Row(children: [Radio<String>(value: 'Poem', groupValue: _contentType, onChanged: (val) => setStateIfMounted(() => _contentType = val!)), const Text('Poem')]),
            ]),
            const SizedBox(height: 16.0),

            // Section: Prompt Input (Updated placeholder and size)
            TextField(controller: _promptController, decoration: InputDecoration(hintText: 'The below is all optional, you could generate content simply by typing a 2-3 sentence prompt with details about your theme, or characters...', border: OutlineInputBorder(borderRadius: BorderRadius.circular(8.0)), contentPadding: const EdgeInsets.all(12.0)), maxLines: 3, keyboardType: TextInputType.multiline),
            const SizedBox(height: 16.0),

            // Section: Theme Selection (Refactored to dialog)
            Text('Select Theme(s) (Up to $_maxThemes):', style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)), // Corrected: Removed const
            const SizedBox(height: 8.0),
            ElevatedButton.icon(icon: const Icon(Icons.palette_outlined), label: Text(themeButtonLabelText), onPressed: _isGenerating ? null : _showThemeSelectionDialog),
            if (_selectedThemes.isNotEmpty) ...[ const SizedBox(height: 8.0), Wrap(spacing: 8.0, runSpacing: 4.0, children: _selectedThemes.map((theme) => Chip(label: Text(theme),onDeleted: _isGenerating ? null : () => setStateIfMounted(() => _selectedThemes.remove(theme)))).toList())],
            const SizedBox(height: 16.0),

            // Section: Character Selection (Refactored)
            Text('Select Character(s) (Up to $_maxCharacters):', style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)), // CORRECTED: Removed const
            const SizedBox(height: 8.0),
            ElevatedButton.icon(icon: const Icon(Icons.person_search), label: Text(characterButtonLabelText), onPressed: _isGenerating ? null : _showCharacterSelectionDialog),
            if (_selectedCharacters.isNotEmpty) ...[ const SizedBox(height: 8.0), Wrap(spacing: 8.0, runSpacing: 4.0, children: _selectedCharacters.map((character) => Chip(label: Text(character),onDeleted: _isGenerating ? null : () => setStateIfMounted(() => _selectedCharacters.remove(character)))).toList())],
            const SizedBox(height: 16.0),

            // Section: Age Range Selection
            const Text('Select Target Age Range:', style: TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)),
            DropdownButtonFormField<String>(decoration: InputDecoration(border: OutlineInputBorder(borderRadius: BorderRadius.circular(8.0)), contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0)), hint: const Text('Choose an age range'), value: _selectedAgeRange, isExpanded: true, items: _availableAgeRanges.map((age) => DropdownMenuItem<String>(value: age, child: Text(age))).toList(), onChanged: _isGenerating ? null : (val) => setStateIfMounted(() => _selectedAgeRange = val)),
            const SizedBox(height: 16.0),

            // Section: Lesson Selection
            Text('Select a Lesson/Moral (Optional, max $_maxLessons):', style: const TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)), // CORRECTED: Removed const
            Wrap(spacing: 8.0, runSpacing: 4.0, children: _availableLessons.map((lesson) {
              return ChoiceChip(label: Text(lesson), selected: _selectedLessons.contains(lesson), onSelected: _isGenerating ? null : (selected) => setStateIfMounted(() { if (selected) { if (_selectedLessons.length < _maxLessons) _selectedLessons.add(lesson); else { _selectedLessons.clear(); _selectedLessons.add(lesson); if(mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Max $_maxLessons lesson can be selected.')));}} else { _selectedLessons.remove(lesson); }}), selectedColor: Theme.of(context).colorScheme.primaryContainer);
            }).toList()),
            const SizedBox(height: 16.0),
            
            // Section: Persona Dropdown
            const Text('Select Persona:', style: TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)),
            _isLoadingPersonas ? const Center(child: Padding(padding: EdgeInsets.all(8.0), child: CircularProgressIndicator()))
                : DropdownButtonFormField<Persona?>(decoration: InputDecoration(border: OutlineInputBorder(borderRadius: BorderRadius.circular(8.0)), contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0)), value: _selectedPersonaObject, isExpanded: true, items: personaDropdownItems, onChanged: _isGenerating ? null : (val) => setStateIfMounted(() => _selectedPersonaObject = val)),
            const SizedBox(height: 16.0),

            // Section: Length Selection
            const Text('Select Story Length:', style: TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)),
            Row(mainAxisAlignment: MainAxisAlignment.center, children: _availableLengths.map((lengthOpt) {
              final String displayTxt = lengthOpt.split('(')[0].trim();
              return Expanded(child: Row(mainAxisSize: MainAxisSize.min, mainAxisAlignment: MainAxisAlignment.center, children: [
                Radio<String>(value: lengthOpt, groupValue: _selectedLength, onChanged: _isGenerating ? null : (val) => setStateIfMounted(() => _selectedLength = val!)),
                Flexible(child: Text(displayTxt))
              ]));
            }).toList()),
            const SizedBox(height: 24.0),

            // Section: Generate Button
            ElevatedButton(
                    onPressed: _isGenerating ? null : () async { 
              String userPrompt = _promptController.text.trim();
              // Removed the prompt empty check based on previous feedback,
              // but consider if a completely empty prompt + no selections is desirable.

              // --- Store current inputs for potential regeneration ---
              _lastUsedPrompt = userPrompt;
              _lastUsedContentType = _contentType;
              _lastUsedThemes = List.from(_selectedThemes);
              _lastUsedCharacters = List.from(_selectedCharacters);
              _lastUsedPersonaObject = _selectedPersonaObject; // This is an object, direct assignment is fine
              _lastUsedAgeRange = _selectedAgeRange;
              _lastUsedLessons = List.from(_selectedLessons);
              _lastUsedLength = _selectedLength;
              _contentHasBeenGenerated = false; // Reset while generating
              // --- End of storing inputs ---

              if(mounted) setStateIfMounted(() { 
                _synopsis = 'Generating...'; 
                _fullText = 'Please wait...';
                // _isGenerating = true; // This is handled at the start of _generateContent now
              });
              
              Map<String, String> generatedContentResult = await _generateContent(
                userPrompt: _lastUsedPrompt!, // Use stored values
                contentType: _lastUsedContentType!,
                selectedThemes: _lastUsedThemes,
                selectedCharacters: _lastUsedCharacters,
                selectedPersonaObject: _lastUsedPersonaObject,
                selectedAgeRange: _lastUsedAgeRange,
                selectedLessons: _lastUsedLessons,
                selectedLength: _lastUsedLength!,
              );
              
              if(mounted) {
                setStateIfMounted(() {
                  _synopsis = generatedContentResult['synopsis'] ?? 'Synopsis error.';
                  _fullText = generatedContentResult['fullText'] ?? 'Content error.';
                  _contentHasBeenGenerated = true; // Mark that content is now available
                });
              }

              // Save to Firestore logic (remains the same, uses current state like _contentType, _synopsis, etc.)
              if (_fullText.isNotEmpty && 
                  !(_fullText.startsWith('Error:') || _fullText.startsWith('Network error:')) && 
                  FirebaseAuth.instance.currentUser != null) {
                try {
                  String userId = FirebaseAuth.instance.currentUser!.uid;
                  Map<String, dynamic> contentData = {
                    'userId': userId, 'type': _contentType, 'synopsis': _synopsis, 'fullText': _fullText, 
                    'prompt': _lastUsedPrompt, // Save the prompt that was used
                    'created_at': FieldValue.serverTimestamp(), 'isPublic': false,
                    'selected_themes': _lastUsedThemes,
                    'selected_characters': _lastUsedCharacters,
                    'selected_persona': _lastUsedPersonaObject?.personaName,
                    'selected_length': _lastUsedLength,
                    'selected_age_range': _lastUsedAgeRange == 'Not Specified' ? null : _lastUsedAgeRange, 
                    'selected_lessons': _lastUsedLessons, 
                  };
                  await FirebaseFirestore.instance.collection('content').add(contentData);
                  if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Content saved successfully!')));
                } catch (e) {
                  if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error saving content: ${e.toString()}')));
                }
              }
            },
              style: ElevatedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12.0), textStyle: const TextStyle(fontSize: 18), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0))),
              child: _isGenerating ? const SizedBox(height: 20, width: 20, child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3.0)) : const Text('Generate Content'),
            ),
            const SizedBox(height: 16.0),
           const SizedBox(height: 8.0), // Spacing
            if (_contentHasBeenGenerated) // Only show if content has been generated
              ElevatedButton.icon(
                icon: const Icon(Icons.refresh),
                label: const Text('Regenerate'),
                onPressed: _isGenerating ? null : () async {
                  print('Regenerate button pressed');
                  if (_lastUsedPrompt == null || _lastUsedContentType == null || _lastUsedLength == null) {
                    _showSnackBar('Previous input not found for regeneration.', isError: true);
                    return;
                  }

                  if(mounted) setStateIfMounted(() {
                    _synopsis = 'Regenerating...';
                    _fullText = 'Please wait...';
                    // _isGenerating = true; // Handled by _generateContent
                  });

                  Map<String, String> regeneratedContentResult = await _generateContent(
                    userPrompt: _lastUsedPrompt!,
                    contentType: _lastUsedContentType!,
                    selectedThemes: _lastUsedThemes,
                    selectedCharacters: _lastUsedCharacters,
                    selectedPersonaObject: _lastUsedPersonaObject,
                    selectedAgeRange: _lastUsedAgeRange,
                    selectedLessons: _lastUsedLessons,
                    selectedLength: _lastUsedLength!,
                  );

                  if(mounted) {
                    setStateIfMounted(() {
                      _synopsis = regeneratedContentResult['synopsis'] ?? 'Synopsis error.';
                      _fullText = regeneratedContentResult['fullText'] ?? 'Content error.';
                    });
                  }
                  // Note: Regenerate does not automatically save. User can save if they like the new version.
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orangeAccent, // Different color for distinction
                  padding: const EdgeInsets.symmetric(vertical: 12.0),
                  textStyle: const TextStyle(fontSize: 18),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
                ),
              ),
            const SizedBox(height: 16.0), // Existing SizedBox before output display
            // Section: Output Display & App Version
            Column(crossAxisAlignment: CrossAxisAlignment.start, children: <Widget>[
              const Text('Synopsis:', style: TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)), const SizedBox(height: 4.0),
              Text(_synopsis, style: const TextStyle(fontSize: 16.0, fontStyle: FontStyle.italic)), const SizedBox(height: 16.0),
              const Text('Full Content:', style: TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold)), const SizedBox(height: 4.0),
              Text(_fullText, style: const TextStyle(fontSize: 16.0)),
            ]),
            const SizedBox(height: 16.0),
            Text('App Version: $_appVersion', style: const TextStyle(fontSize: 12.0, fontStyle: FontStyle.italic), textAlign: TextAlign.center),
          ],
        ),
      ),
    );
  }
} // End of _HomePageState class